#!/usr/bin/python

'''################################################################
(c) Alain Cherpin - alain.cherpin@gmail.com

Released under GNU GENERAL PUBLIC LICENSE, Version 3, 29 June 2007

Given a sequence of music notes, draw a piano keyboard
with marks on the corresponding keys

The note sequence must be from low to high (left to right)
The chord name may be provided to be printed above the keyboard
Note names may be printed below the keyboard

Synopsis:
showchord [-h] [--keyprint] [--fileprefix FILEPREFIX] [--export]
                 [--zoom ZOOM] ['C E G B;Cmaj7' '' 'a c# e g#;Amaj7']

Three examples giving the same result:

# chords given at command line
showchord -k -e -z 3 'C E G B;Cmaj7' '' 'a c# e g#;Amaj7'

# chords given from a pipe stream
echo 'C E G B;Cmaj7' '' 'a c# e g#;Amaj7' | showchord -k -e -z 3

# chords provided from a file stream
cat >chords.lst<<EOF
C E G B;Cmaj7

a c# e g#;Amaj7
EOF

showchord -k -e -z 3 < chords.lst

$ showchord -e -k -z 3
'C E G;C'
'a c# e g#;Amaj7'
''
';Dmin7'
^C

if no chord is given, then switches to stream mode and waits for 
input from stdin

NOTE: chords as arguments override any stream input, i.e: stream
input is switched on only if no chord is provided as arguments

requirements:
 linux like OS
 python2+
 inkscape 0.92+ (export function)
##################################################################'''

## module import

# required to use print(string, file=sys.stdout) in python 2
from __future__ import print_function

import os, sys, subprocess
import argparse
from collections import namedtuple

## constants
WTE_WIDTH = 10
WTE_HEIGHT = (4 * WTE_WIDTH)
WTE_INIT_OFFSET = 0
WTE_COLOR = "#ffffff"
WTE_OPACITY = 1
WTE_TYPE = 0
WTE_MARK_V_OFFSET = (3.2 * WTE_WIDTH)
WTE_MARK_COLOR = "#000000"

BLK_SHIFT = 1     # specific black key shift value
BLK_WIDTH = 6
BLK_HEIGHT = (4 * BLK_WIDTH)
BLK_INIT_OFFSET = (WTE_WIDTH - (BLK_WIDTH / 2) )
BLK_COLOR = "#000000"
BLK_OPACITY = 1
BLK_TYPE = 1
BLK_MARK_V_OFFSET = (2.7 * BLK_WIDTH)
BLK_MARK_COLOR = "#ffffff"


OUTPUT = sys.stdout
SVG_ID = "chords"
HEIGHT_TITLE = 20
HEIGHT_PRINTKEY = 15
CHORD_Y_SHIFT = 20
MARK_RADIUS = 3

EXPORT_CMD = {'inkscape': ' -D -f {} -e {} >/dev/null',
              'rsvg-convert': ' {} -o {} -a >/dev/null'}

export_cmd = ''

## variables fed from arguments

# list of chords of the forme 'N N N N;Chord Name'
chords = []

# print note name under marked key
keyprint = False

# export to PNG
export = False

# file prefix to compose output file
fileprefix = 'chord_'

# free space above keyboard to print title
height_title = 0

# free space below keyboard to print note names
height_keyprint = 0

# zoom value
zoom = 1

# 35 representable notes on a single scale with
# their index on the scale
NOTES = {'Cbb' : 10,
         'Cb': 11,
         'C' : 0,
         'C#': 1,
         'Cx': 2,
         'Dbb': 0,
         'Db': 1,
         'D' : 2,
         'D#' : 3,
         'Dx' : 4,
         'Ebb': 2,
         'Eb': 3,
         'E': 4,
         'E#': 5,
         'Ex': 6,
         'Fbb': 3,
         'Fb': 4,
         'F': 5,
         'F#': 6,
         'Fx': 7,
         'Gbb': 5,
         'Gb': 6,
         'G': 7,
         'G#': 8,
         'Gx': 9,
         'Abb': 7,
         'Ab': 8,
         'A': 9,
         'A#': 10,
         'Ax': 11,
         'Bbb': 9,
         'Bb': 10,
         'B': 11,
         'B#': 0,
         'Bx': 1}

###########################
# define a note representation

# key dimensions
KeyDim = namedtuple('KeyDim', ['width', 'height'])

# key appearence
KeyApp = namedtuple('KeyApp', ['color'])

# key mark spec
KeyMark = namedtuple('KeyMark', ['color', 'v_offset'])

# key type (black or white)
KeyType = namedtuple('NteType', ['h_init_offset', 'dim', 'app', 'mark'])

# 2 types of keys
## white
wte_dim = KeyDim(WTE_WIDTH, WTE_HEIGHT)
wte_app = KeyApp(WTE_COLOR)
wte_mark = KeyMark(WTE_MARK_COLOR, WTE_MARK_V_OFFSET)
white = KeyType(WTE_INIT_OFFSET, wte_dim, wte_app, wte_mark)

## black
blk_dim = KeyDim(BLK_WIDTH, BLK_HEIGHT)
blk_app = KeyApp(BLK_COLOR)
blk_mark = KeyMark(BLK_MARK_COLOR, BLK_MARK_V_OFFSET)
black = KeyType(BLK_INIT_OFFSET, blk_dim, blk_app, blk_mark)

# note lists for drawing keyboard as in SVG black keys
# must be after to override white keys
WHITES = ['C', 'D', 'E', 'F', 'G', 'A', 'B']
BLACKS = ['C#', 'D#', 'F#', 'G#', 'A#']

# 12 notes representation by id, ordered from their 
# position on the piano keyboard
# the implicite id is the link between NOTES and NOTES_REPR
# First value is white note index
# Second value is shift direction -1:left, 0:center, 1:right
# white or black are structure containing drawing information
NOTES_REPR = []
NOTES_REPR.append([0, 0, white])	# 0  : C
NOTES_REPR.append([0, -1, black])       # 1  : C#
NOTES_REPR.append([1, 0, white]) 	# 2  : D
NOTES_REPR.append([1, 1, black])	# 3  : D#
NOTES_REPR.append([2, 0, white])	# 4  : E
NOTES_REPR.append([3, 0, white])	# 5  : F
NOTES_REPR.append([3, -1, black])	# 6  : F#
NOTES_REPR.append([4, 0, white])	# 7  : G
NOTES_REPR.append([4, 0, black])	# 8  : G#
NOTES_REPR.append([5, 0, white])	# 9  : A
NOTES_REPR.append([5, 1, black])	# 10 : A#
NOTES_REPR.append([6, 0, white])	# 11 : B

###############################################
# functions
###############################################

###############################################
# command line arguments
def args():
    global chords
    global keyprint
    global height_keyprint
    global export
    global fileprefix
    global zoom

    parser = argparse.ArgumentParser(description='Show chord notes on a piano keyboard')

    # optional list of chords
    # if no chord provided then enter in stream mode
    # chords is a list of chords of the form 'N N N;chord title'
    # ex: 'D F# A;D major' 'e g# B;E' 'E A b c'
    parser.add_argument('chords',
	nargs='*',
	help='Notes of the chord, followed or not by chord name - ex. "C Eb Gb Bbb;Cdim7" "C E G"')

    # print note name below each marked key
    parser.add_argument('--keyprint', '-k',
	action='store_true',
	help='Print note key names below the keyboard')

    # set prefix for automatic file name
    parser.add_argument('--fileprefix', '-f',
	action='store',
	help='File prefix to auto-generated filenames to store chord images')

    # export to PNG image file format
    parser.add_argument('--export', '-e',
	action='store_true',
	help='Export to PNG file')

    # zoom output SVG image (and PNG if --export is set)
    parser.add_argument('--zoom', '-z',
	type=float,
	action='store',
	help='Zoom value (float), e.g: 2.0 to double output SVG drawing size')

    # parse command line and set args.<option> values
    args = parser.parse_args()

    # store provided chords in chords list
    for chord in args.chords:
        chords.append(chord)

    # store keyprint choice, if true set height of note name space
    keyprint = args.keyprint
    if keyprint:
        height_keyprint = HEIGHT_PRINTKEY

    # override default fileprefix
    if args.fileprefix:
        fileprefix = args.fileprefix

    # store export choice
    export = args.export

    # store zoom factor
    if args.zoom:
        zoom = args.zoom

###############################################
# check if external cmd exists and is executable on OS
# return command full name on success
# or empty string on failed search
def export_cmd_fullname(cmd):
    for path in os.environ["PATH"].split(os.pathsep):
        if os.access(os.path.join(path, cmd), os.X_OK):
            return os.path.join(path, cmd)
    return ''

###############################################
# return full shell svg to png command
# expression made out of EXPORT_CMD dictionary
# content
# return an empty string if none commands are
# found on the OS
def export_cmd_expr():
    cmds = EXPORT_CMD.keys()
    cmds.sort()
    for cmd in cmds:
        cmd_name = export_cmd_fullname(cmd)
        if not cmd_name:
            continue
        return cmd + EXPORT_CMD[cmd]

    return ''

###############################################
# print begining of svg file
def svg_open(title, height_kprint):
    svg_header = '''<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<svg
   xmlns:dc="http://purl.org/dc/elements/1.1/"
   xmlns:cc="http://creativecommons.org/ns#"
   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
   xmlns:svg="http://www.w3.org/2000/svg"
   xmlns="http://www.w3.org/2000/svg"
   id="chords"
   version="1.1"
   preserveAspectRatio="xMinYMin meet"
   viewBox="{} {} {} {}"
   width="{}"
   height="{}">
  <defs
     id="defs4516" />
  <metadata
     id="metadata4519">
    <rdf:RDF>
      <cc:Work
         rdf:about="">
        <dc:format>image/svg+xml</dc:format>
        <dc:type
           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
        <dc:title></dc:title>
      </cc:Work>
    </rdf:RDF>
  </metadata>'''

    height = HEIGHT_TITLE
    if title == '': height = 0
    vbox_x = 0
    vbox_y = 0
    vbox_width = 142 * zoom
    vbox_heigth = (30 + height) * zoom
    width = 142 * zoom
    height = (42 + height + height_kprint) * zoom
    print(svg_header.format(vbox_x,
                            vbox_y,
                            vbox_width,
                            vbox_heigth,
                            width,
                            height),
                            file=OUTPUT)

###############################################
# print svg group open
def svg_g_open(title):
    x_translate = 1
    y_translate = 1
    if title != '':
        y_translate = CHORD_Y_SHIFT * zoom
        svg_draw_title(title)

    svg_group = '''  <g
    transform="translate({},{})"
    id="chord{}">'''

    print(svg_group.format(x_translate,
                           y_translate,
                           title),
                           file=OUTPUT)

###############################################
# print svg group end
def svg_g_close():
    print("  </g>", file=OUTPUT)

###############################################
# print svg file end
def svg_close():
    print("</svg>", file=OUTPUT)

###############################################
# draw the given key as svg rectangle
def svg_draw_key(octave_shift, notename):

    # retrieve key structure from notename
    key = NOTES_REPR[NOTES[notename]]

    x = octave_shift + ((key[0] * WTE_WIDTH) + key[2].h_init_offset) * zoom
    y = 0
    svg_key = '''    <rect
    id="{}"
    width="{}"
    height="{}"
    x="{}"
    y="{}"
    style="fill:{};fill-opacity:1;stroke:#000000;stroke-width:1;stroke-opacity:1"
    />'''
    print(svg_key.format(key,
                         key[2].dim.width * zoom,
                         key[2].dim.height * zoom,
                         x,
                         y,
                         key[2].app.color),
                         file=OUTPUT)

##############################################
# draw a mark on the given note as svg circle
def svg_draw_mark(octave_shift, notename):

    # retrieve key structure from notename
    key = NOTES_REPR[NOTES[notename]]

    r_value = MARK_RADIUS * zoom
    cx = octave_shift + ((key[0] * WTE_WIDTH + (WTE_WIDTH / 2)) + key[2].h_init_offset * 0.7) * zoom
    cy = key[2].mark.v_offset * zoom
    svg_mark = '''  <circle
  id="path{}"
  r="{}"
  cx="{}"
  cy="{}"
  style="fill:{};fill-opacity:1;stroke-width:0.38909313"
  />'''

    print(svg_mark.format(key,
                          r_value,
                          cx,
                          cy,
                          key[2].mark.color),
                          file=OUTPUT)

###############################################
def svg_draw_keyname(octave_shift, notename):

    # retrieve key structure from notename
    key = NOTES_REPR[NOTES[notename]]

    font_size = 0.5 * zoom
    x = octave_shift + ((key[0] * WTE_WIDTH + ((WTE_WIDTH - len(notename) * (font_size + 1)) / 2) + key[2].h_init_offset * 0.5)) * zoom
    y = (key[2].mark.v_offset * 1.6 + (key[2].h_init_offset * 2.8)) * zoom
    line_height = 1.25 * zoom
    line_height = font_size * zoom

    keyname = '''  <text
     id="key_{}"
     y="{}"
     x="{}"
     style="font-style:normal;font-weight:bold;font-size:{}em;line-height:{};font-family:monospace;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;stroke-width:0.26458332"
     xml:space="preserve"><tspan
       id="tspan_{}">{}</tspan>
  </text>'''
    print(keyname.format(notename,
                         y,
                         x,
                         font_size,
                         line_height,
                         notename,
                         notename),
                         file=OUTPUT)

###############################################
# draw chord name as svg text
def svg_draw_title(title):
    y = 14 * zoom
    x = ((140 - (len(title) * 8)) / 2) * zoom
    font_size = zoom
    line_height = 1.25 * zoom
    svg_title = '''  <text
     id="title_{}"
     y="{}"
     x="{}"
     style="font-style:normal;font-weight:bold;font-size:{}em;line-height:{};font-family:monospace;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;stroke-width:0.26458332"
     xml:space="preserve"><tspan
       id="tspanTITLE">{}</tspan>
  </text>'''

    print(svg_title.format(title,
                           y,
                           x,
                           font_size,
                           line_height,
                           title),
                           file=OUTPUT)

###############################################
# draw a 2 octaves keyboard
def draw_svg_kbd():

    o_shift = 0
    # draw notes of 2 octaves
    for octv in range(0,2):
        o_shift = (octv * 7 * WTE_WIDTH * zoom)
        for note in WHITES:
            svg_draw_key(o_shift, note)

        for note in BLACKS:
            svg_draw_key(o_shift, note)

###############################################
def svg_draw_chord(ch, ch_name):

    svg_g_open(ch_name)

    # draw keyboard on 2 octaves
    draw_svg_kbd()

    ## draw a mark on the keys of the given chord
    #  and the note name if keyprint is set

    if not ch:
        svg_g_close()
        return 0

    octv_shift = 0
    key_idx = 0

    for note in ch:
        k_idx = NOTES[note]
        if k_idx < key_idx:
            octv_shift = (7 * WTE_WIDTH * zoom)
        svg_draw_mark(octv_shift, note)
        if keyprint:
            svg_draw_keyname(octv_shift, note)
        key_idx = k_idx

    svg_g_close()
    return 0

###############################################
# check if all note names in given chord are correct
# else raise a NameError exception that returns the bad note name
def check_chord(ch):
    cleaned_chord = []
    for note in ch:
        if note.capitalize() in NOTES:
            cleaned_chord.append(note.capitalize())
        else:
            # note not found
            raise NameError(note)

    return cleaned_chord

###############################################
# cleanup name to be OS compatible
def sanitize(name):
    tmp = name.replace("_ ", "_")
    tmp = tmp.replace(" ", "_")
    tmp = tmp.replace("#","s")
    return tmp

###############################################
# add or replace filename extension
# return name with the given extension
def set_extension(name, ext):
    if name == '':
        return name

    tmplist = name.split(".")

    # remove extension if present
    if len(tmplist) > 1:
        del tmplist[len(tmplist) - 1]

    # recompose original name without original ext
    # and add the given extension
    return '.'.join(tmplist) + ext

###############################################
# main ########################################
###############################################

# get script options and arguments
# this may provide chords in chords list
args()

# read standard input (stream mode) only if no chord
# are present in chords list
# stream mode means read input stream until EOF is reached and
# draw one chord for each line.
# line should be of the following form:
# C E G;C major
# i.e: 2 parts: chord;chordname
if not chords:
    try:
        for line in sys.stdin:
            # remove trailing '\n'
            line = ' '.join(line.split())

            # ignore commented or empty lines
            if line[0:1] == '#' or line == '':
                continue

            # add line chord[;title] to chords list
            chords.append(line)
    except KeyboardInterrupt:
        print()     # for a clean CLI exit
        sys.exit(2)


# chords is not empty if we reach this point
index = 0
for line in chords:

    # extract chord and title
    parts = line.split(';')

    # store chord in a list of notes
    chord = parts[0]
    chord = chord.capitalize().split()   # first letter uppercase

    # if chord empty then reset key print space
    # else set user defined choice from --keyprint
    h_kprint = height_keyprint
    if not chord:
        h_kprint = 0

    # store title
    title = ''
    if len(parts) > 1:
        title = parts[1]
        if title == r'\\':
            title = ' '

    # exit if at least one bad note name is given
    try:
        chord = check_chord(chord)
    except NameError as e:
        print('''
Error: "{}" is not a valid input
  - Authorized note names are:
    C D E F G A B
  - Accidentals are:
    # (sharp/dieze)
    b (flat/bemol)
    x (## double sharp / double dieze)
    bb (double flat / double bemol)

  e.g: "C Eb Gb Bbb;Cdim7" "C E G;C major"

  Try --help for more info
        '''.format(str(e)), file=sys.stderr)
        sys.exit(1)

    # make output file name
    if title and title != ' ':
        svgname = fileprefix + title + '_' + str(index)
    else:
        svgname = fileprefix + str(index)

    svgname = set_extension(sanitize(svgname), '.svg')

    # OUTPUT default is sys.stdout
    OUTPUT = open(svgname, 'w')

    svg_open(title, h_kprint)
    svg_draw_chord(chord, title)
    svg_close()

    OUTPUT.close()

    # export to PNG if --export == True
    if export:
        # set export command depending on what's installed on system
        export_cmd = export_cmd_expr()
        pngname = set_extension(svgname, '.png')

        if export_cmd != '':
            # export_cmd expression must contain exactely 2 pairs of empty
            # braces ...{}...{}... to be filled with svg_name and export_fname
            subprocess.call(export_cmd.format(svgname, pngname), shell=True)
        else:
            print("No export command found in " + str(EXPORT_CMD.keys()),
                  file=sys.stderr)

    # next chord
    index = index + 1

sys.exit(0)

################################################################
