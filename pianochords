#!/usr/bin/python3

# ################################################################
# (c) Alain Cherpin - uxiyon@gmail.com
#
# given a sequence of music notes, draw a piano keyboard
# with marks on the corresponding keys and return the name
# of the produced file
# sequence is from low to high (left to right)
# chord name may be provided to be printed above the keyboard
# note names may be printed below the keyboard
# synopsys : chords [--notes "c e g"] 
#                   [--name "C"]
#                   [--printkey]
#
# if no chord is given, then only draw a 2 octaves keyboard
#
# requirements:
# linux like OS
# python3+
# inkscape 0.92+
##################################################################

##################################################################
# TODO:
# - OK: provide as many chords a we want through a file
#   OK (no JSON yet): i.e: take the input from a stream (JSON ?)
# - provide main chords
# - if more than one chord is provided, organize them in an array
# - allow to give a title to the page
# - allow to export to pdf
##################################################################

## module import
import sys, subprocess
from collections import namedtuple
from optparse import OptionParser
from contextlib import redirect_stdout

## constants
WTE_WIDTH = 10
WTE_HEIGHT = (4 * WTE_WIDTH)
WTE_INIT_OFFSET = 0
WTE_COLOR = "#ffffff"
WTE_OPACITY = 1
WTE_TYPE = 0
WTE_MARK_V_OFFSET = (3.2 * WTE_WIDTH)
WTE_MARK_COLOR = "#00c000"

BLK_SHIFT = 1     # specific black key shift value
BLK_WIDTH = 6
BLK_HEIGHT = (4 * BLK_WIDTH)
BLK_INIT_OFFSET = (WTE_WIDTH - (BLK_WIDTH / 2) )
BLK_COLOR = "#000000"
BLK_OPACITY = 1
BLK_TYPE = 1
BLK_MARK_V_OFFSET = (2.7 * BLK_WIDTH)
BLK_MARK_COLOR = "#00c000"

OUTPUT = sys.stdout
TMP_FILENAME = "new_chord"
SVG_ID = "chords"
HEIGHT_TITLE = 20
HEIGHT_PRINTKEY = 15
CHORD_Y_SHIFT = 20

## variables fed from arguments
chord = []
chord_input = ''
chord_name = ''
print_key = False
export = False
stream_mode = False
filename = ''
header_printed = False
height_title = 0
height_printkey = 0

###########################
# define a note representation
Key = namedtuple('Key', ['name', 'index', 'h_offset', 'h_shift', 'type'])
KeyDim = namedtuple('KeyDim', ['width', 'height'])
KeyApp = namedtuple('KeyApp', ['color'])
KeyMark = namedtuple('KeyMark', ['color', 'v_offset'])
KeyType = namedtuple('NteType', ['h_init_offset', 'dim', 'app', 'mark'])

# 2 types of keys
## white
wte_dim = KeyDim(WTE_WIDTH, WTE_HEIGHT)
wte_app = KeyApp(WTE_COLOR)
wte_mark = KeyMark(WTE_MARK_COLOR, WTE_MARK_V_OFFSET)
white = KeyType(WTE_INIT_OFFSET, wte_dim, wte_app, wte_mark)

## black
blk_dim = KeyDim(BLK_WIDTH, BLK_HEIGHT)
blk_app = KeyApp(BLK_COLOR)
blk_mark = KeyMark(BLK_MARK_COLOR, BLK_MARK_V_OFFSET)
black = KeyType(BLK_INIT_OFFSET, blk_dim, blk_app, blk_mark)

# define all 12 notes
C_flat  = Key('Cb', 12, 6, 0, white)
C       = Key('C', 1, 0, 0, white)
C_sharp = Key('C#', 2, 0, -1, black)

D_flat  = Key('Db', 2, 0, -1, black)
D       = Key('D', 3, 1, 0, white)
D_sharp = Key('D#', 4, 1, 1, black)

E_flat  = Key('Eb', 4, 1, 1, black)
E       = Key('E', 5, 2, 0, white)
E_sharp = Key('E#', 6, 3, 0, white)

F_flat  = Key('Fb', 5, 2, 0, white)
F       = Key('F', 6, 3, 0, white)
F_sharp = Key('F#', 7, 3, -1, black)

G_flat  = Key('Gb', 7, 3, -1, black)
G       = Key('G', 8, 4, 0, white)
G_sharp = Key('G#', 9, 4, 0, black)

A_flat  = Key('Ab', 9, 4, 0, black)
A       = Key('A', 10, 5, 0, white)
A_sharp = Key('A#', 11, 5, 1, black)

B_flat  = Key('Bb', 11, 5, 1, black)
B       = Key('B', 12, 6, 0, white)
B_sharp = Key('B#', 1, 0, 0, white)

# all 12 notes ordered to be drawn in svg
# the order is important for the black to overlap whites
TWELVE = [C, D, E, F, G, A, B, B_sharp, C_sharp, D_sharp, E_sharp, F_sharp, G_sharp, A_sharp]

# all 12 notes of an octave
#OCTAVE = [C, C_sharp, D, D_sharp, E, F, F_sharp, G, G_sharp, A, A_sharp, B]

ALL_NOTES = [C, D, E, F, G, A, B,
             C_sharp, D_sharp, E_sharp, F_sharp, G_sharp, A_sharp, B_sharp,
             C_flat, D_flat, E_flat, F_flat, G_flat, A_flat, B_flat]

## known chords
#MAJOR_C = "C E G"
#MAJOR_C1 = "E G C"
#MAJOR_C2 = "G C E"
#
#major = [0, 4, 7]
#ref = C
#
#print(OCTAVE[r].name)
#print(OCTAVE[r+4].name)
#print(OCTAVE[r+7].name)
#
#def name_chord(note_serie):
#    lst = note_serie.split()
#    for n in lst:
#        
#
#
#sys.exit(99)

###############################################
# functions

###############################################
def usage():
    print("Usage: TODO")

###############################################
# check arguments
def args():
    global chord
    global chord_input
    global chord_name
    global height_title
    global print_key
    global height_printkey
    global export
    global filename
    global stream_mode

    parser = OptionParser()
    parser.add_option("-c", "--chord", action="store", dest="ch")
    parser.add_option("-n", "--chordname", action="store", dest="chname")
    parser.add_option("-p", "--printkey", action="store_true", dest="printkey", default=False)
    parser.add_option("-e", "--export", action="store_true", dest="export", default=False)
    parser.add_option("-f", "--file", action="store", dest="filename")
    parser.add_option("-s", "--stream", action="store_true", dest="stream", default=False)

    (options, args) = parser.parse_args()

    # chord is a list of notes
    if options.ch != None:
        chord_input = options.ch.title()
        chord = options.ch.split()

    # chord name is optionnal
    if options.chname != None:
        chord_name = options.chname
        height_title = HEIGHT_TITLE

    # store printkey choice
    print_key = options.printkey
    if print_key:
        height_printkey = HEIGHT_PRINTKEY

    # store export choice
    export = options.export

    # store export filename
    if options.filename != None:
        filename = options.filename

    # activate stream mode
    stream_mode = options.stream 

###############################################
# print begining of svg file
def svg_open():
    svg_header = '''<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<svg
   xmlns:dc="http://purl.org/dc/elements/1.1/"
   xmlns:cc="http://creativecommons.org/ns#"
   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
   xmlns:svg="http://www.w3.org/2000/svg"
   xmlns="http://www.w3.org/2000/svg"
   id="chords"
   version="1.1"
   preserveAspectRatio="xMinYMin meet"
   viewBox="{} {} {} {}"
   width="{}"
   height="{}">
  <defs
     id="defs4516" />
  <metadata
     id="metadata4519">
    <rdf:RDF>
      <cc:Work
         rdf:about="">
        <dc:format>image/svg+xml</dc:format>
        <dc:type
           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
        <dc:title></dc:title>
      </cc:Work>
    </rdf:RDF>
  </metadata>'''

    vbox_x = 0
    vbox_x = 0
    vbox_width = 141
    vbox_heigth = 30 + height_title
    width = 141
    height = 40 + height_title + height_printkey
    print(svg_header.format(vbox_x, vbox_x, vbox_width, vbox_heigth, width, height))

###############################################
# print svg group open
def svg_g_open(cho_name):
    x_translate = 0
    y_translate = 0
    if cho_name != '':
        y_translate = CHORD_Y_SHIFT
        svg_draw_title(cho_name)

    svg_group = '''  <g
    transform="translate({},{})"
    id="chord{}">'''

    print(svg_group.format(x_translate, y_translate, cho_name))

###############################################
# print svg group end
def svg_g_close():
    print("  </g>")

###############################################
# print svg file end
def svg_close():
    print("</svg>")

###############################################
# draw the given key as svg rectangle
def svg_draw_key(octave_shift, key):
    x = (octave_shift + (key.h_offset * WTE_WIDTH) + key.type.h_init_offset)
    y = 0
    svg_key = '''    <rect
    id="{}"
    width="{}"
    height="{}"
    x="{}"
    y="{}"
    style="fill:{};fill-opacity:1;stroke:#000000;stroke-width:0.26458332;stroke-opacity:1"
    />'''
    print(svg_key.format(key.index,
                         key.type.dim.width,
                         key.type.dim.height,
                         x,
                         y,
                         key.type.app.color))

##############################################
# draw a mark on the given note as svg circle
def svg_draw_mark(octave_shift, key):
    r_value = 2.7807205
    cx=(octave_shift + (key.h_offset * WTE_WIDTH + (WTE_WIDTH / 2)) + key.type.h_init_offset * 0.7 )
    cy=key.type.mark.v_offset
    svg_mark = '''  <circle
  id="path{}"
  r="{}"
  cx="{}"
  cy="{}"
  style="fill:{};fill-opacity:1;stroke-width:0.38909313"
  />'''

    print(svg_mark.format(key.index,
                          r_value,
                          cx,
                          cy,
                          key.type.mark.color))

###############################################
def svg_draw_keyname(octave_shift, key):
    x = (octave_shift + (key.h_offset * WTE_WIDTH + (WTE_WIDTH * 0.25)) + key.type.h_init_offset * 0.5 )
    y = (key.type.mark.v_offset * 1.6 + (key.type.h_init_offset * 2.8))

    keyname = '''  <text
     id="key_{}"
     y="{}"
     x="{}"
     style="font-style:normal;font-weight:normal;font-size:6px;line-height:1.25;font-family:monospace;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;stroke-width:0.26458332"
     xml:space="preserve"><tspan
       id="tspan_{}">{}</tspan>
  </text>'''
    print(keyname.format(key.name.title(), y, x, key.name.title(), key.name.title()))

###############################################
# draw chord name as svg text
def svg_draw_title(label):
    y = 12
    x = ((140 - (len(label) * 6)) / 2)
    svg_title = '''  <text
     id="title_{}"
     y="{}"
     x="{}"
     style="font-style:normal;font-weight:normal;font-size:10px;line-height:1.25;font-family:monospace;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;stroke-width:0.26458332"
     xml:space="preserve"><tspan
       id="tspanTITLE">{}</tspan>
  </text>'''

    print(svg_title.format(sanitize(label), y, x, label))

###############################################
# draw a 2 octaves keyboard
def draw_svg_kbd(cho_name):
    svg_g_open(cho_name)

    o_shift = 0
    # draw notes of 2 octaves
    for octv in range(0,2):
        o_shift = (octv * 7 * WTE_WIDTH)
        for nte in TWELVE:
            svg_draw_key(o_shift, nte)


###############################################
def svg_draw_chord(ch, ch_name):

    # draw keyboard on 2 octaves
    draw_svg_kbd(ch_name)

    ## draw a mark on the keys of the given chord
    #  and the note name if print_key is set
    octv_shift = 0
    key_idx = 0

    for note in ch:
        k = next(key for key in ALL_NOTES if key.name == note.title())
        if k.index < key_idx:
            octv_shift = (7 * WTE_WIDTH)
        svg_draw_mark(octv_shift, k)
        if print_key:
            svg_draw_keyname(octv_shift, k)
        key_idx = k.index

    svg_g_close()

###############################################
# check if all note names in given chord are correct
# else raise a NameError exception returning bad note name
def check_chord(ch):
    sanit_chord = []

    for note in ch:
        try:
            k = next(key for key in ALL_NOTES if key.name == note.title())
            sanit_chord.append(note.title())

        # note not found
        except StopIteration:
            raise NameError(note)

    return sanit_chord

###############################################
def sanitize(name):
    tmp = name.replace(" ", "_")
    tmp = tmp.replace("#","sharp")
    tmp = tmp.replace("b","flat")
    return tmp

###############################################
# add or replace filename extension
# return name with the given extension
def set_extension(name, ext):

    if name == '':
        return name

    tmplist = name.split(".")

    # remove extension if present
    if len(tmplist) > 1:
        del tmplist[len(tmplist) - 1]

    # recompose original name without original ext
    # and add the given extension
    return '.'.join(tmplist) + ext

###############################################
## main

# get script options and arguments
args()

# exit if at least one bad note name is given
try:
    chord = check_chord(chord)
except NameError as e:
    print('''"{}" is not a valid note name
    Authorized note names are:
    C D E F G A B
    Accidentals are # and b
    e.g: "C Eb G#"'''.format(str(e)))
    sys.exit(1)

# stream mode means read input stream until EOF is reached and
# draw one chord for each line.
# line should be of the following form:
# C E G;C major
# i.e: 2 parts: chord;chord_name

if stream_mode:
    for line in sys.stdin:
        # forward options
        export_option = ''
        if export:
            export_option = ' --export'

        printkey_option = ''
        if print_key:
            printkey_option = ' --printkey'

        chord_parts = line.split(';')
        if len(chord_parts) > 0:
            chord_option = chord_parts[0]
        else:
            next

        if len(chord_parts) > 1:
            # join used to remove trailing \n
            chord_name_option = ''.join(chord_parts[1].split())
        else:
            chord_name_option = '-'.join(chord_option.split())
            # first letter uppercase
            chord_name_option = chord_name_option.title()

        cmdline = sys.argv[0] + ' --chord "' + chord_option + '" --chordname "' + chord_name_option + '"' + export_option + printkey_option

        # call chords script in normal mode
        subprocess.call(cmdline, shell = True)

    sys.exit(0)


# not in stream mode
svg_name = ''

# filename is given, first assume it is for svg output
if filename != '':
    svg_name = set_extension(filename, ".svg")

# export to png
if export:
    ext = ".png"
    export_fname = set_extension(TMP_FILENAME, ext)
    if filename != '':
        export_fname = set_extension(filename, ext)
    elif chord_name != '':
        export_fname = set_extension(sanitize(chord_name), ext)
    elif len(chord) > 0:
        export_fname = set_extension(sanitize('-'.join(chord_input.split())), ext)

    if svg_name == '':
        svg_name = set_extension(export_fname, ".svg")



# automatically write to stdout or
# to a file depending on --export option
if export or filename != '':
    # OUTPUT default is sys.stdout
    OUTPUT = open(svg_name, 'w')

# first export to svg
with redirect_stdout(OUTPUT):
    svg_open()
    svg_draw_chord(chord, chord_name)
    svg_close()
    OUTPUT.close()

# export svg to png bitmap
if export:
    subprocess.call("/usr/bin/inkscape -f {} -e {} >/dev/null".format(svg_name, export_fname), shell=True)
    #subprocess.call("/bin/rm -f {}".format(svg_name), shell=True)

sys.exit(0)
